# .Net Core自带的依赖注入框架的作用域及释放

## 释放

这里的释放是指释放掉对象存储的内存。

容器内的持久化实例池只是保存了对象内存地址的引用，每次容器生命周期结束时都会释放掉持久化实例池，但和实际内存的释放不同。

实际释放要看该对象的释放是否归容器管理，不归容器管理的容器不会释放，会归于CLR的GC机制去释放。

* 容器接管释放原理：

容器被释放时，会去遍历当前容器内的可释放实例池，然后调用每个实例的Dispose方法，对实例进行释放

* 可释放实例是什么时候添加到可释放实例池中的：

在容器解析实例时，会判断该组件是否实现了IDisposable接口，如果实现了，在实例化对象后，会将其持久化到可释放实例池中。

综上，可以得到如下结论：

* 结论1：只有实现了IDisposable接口的类**才有可能**被容器接管释放，没有实现IDisposable接口的**一定不会**被容器接管释放，只会由CLR管理
* 结论2：只有由容器实例化出的对象**才有可能**被容器接管释放，其他均不会（因为只有容器解析实例时才会去持久化可释放实例池）

根据上面结论，可以得出一个比较吊诡的特例：

即注册自己new出的实例时，将其注册为单例到容器中，该类虽然实现了IDisposable接口，但是并不会由容器接管释放。

因为其违反了结论2，其解析服务时不是容器实例化，是直接从注册信息中拿到了之前new出对象的地址，既不会存储到持久化实例池，也不会存储到可释放实例池。

当向容器注册时，只会向容器内的注册信息池保存注册信息，不会操作持久化实例池和可释放实例池，只有解析并实例化时才会有可能向可释放实例池添加实例对象。

（至于为什么不在注册时就将其添加到持久化实例池和可释放实例池，我个人觉得算是框架未完成的需求（或者说是遗留的无伤大雅的bug）。持久化实例池是容器的一个私有属性（ResolvedServices），可释放实例池在容器的一个私有变量（_disposables），然而在注册阶段，容器还没有生成（构建器builder还未执行build），所以没有添加。但是未来会不会更改，暂时不好说，因为按照逻辑看，我个人觉得这种情况的实例是应该让容器接管释放的）

对应测试用例见05号用例。

### 测试用例01：瞬时实例的释放

构造注入时，实例化出对象，不会存储到持久化实例池，会存储到可释放实例池

请求结束，释放掉请求容器，同时容器会释放对象

### 测试用例02：域内单例的释放

构造注入时，实例化出对象，会同时存储到持久化实例池和可释放实例池。

子域生命周期结束后被释放，同时子域内的对象被释放。

请求结束，请求容器被释放，容器内对象被释放。

### 测试用例03：全局单例的释放

构造注入时，实例化出对象，会同时存储到**根域**的持久化实例池和可释放实例池。

请求结束，请求容器被释放，但是根域并不会被释放，所以单例对象不会被释放。

### 测试用例04：全局单例的释放

构造注入时，实例化出对象，会同时存储到**根域**的持久化实例池和可释放实例池。

请求结束，停止整个应用，此时根域会被释放，同时单例对象会被释放。

### 测试用例05：全局单例的释放-自己new出的实例

注册时，自己new一个实例，然后注册为全局单例。

构造注入时，不会实例化对象，直接根据注册信息中保存的实例地址拿到之前new出的对象，这时既不会存储到持久化实例池，也不会存储到可释放实例池。

请求结束，停止整个应用，此时根域会被释放，但new出的实例对象并不会被释放掉，因为其并不在可释放实例池中。